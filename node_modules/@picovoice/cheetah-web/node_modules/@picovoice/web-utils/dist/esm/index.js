function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var regeneratorRuntime$1 = {exports: {}};

var _typeof$1 = {exports: {}};

_typeof$1.exports;

(function (module) {
	function _typeof(o) {
	  "@babel/helpers - typeof";

	  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
	    return typeof o;
	  } : function (o) {
	    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
	}
	module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (_typeof$1));

var _typeofExports = _typeof$1.exports;

regeneratorRuntime$1.exports;

(function (module) {
	var _typeof = _typeofExports["default"];
	function _regeneratorRuntime() {
	  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
	    return e;
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
	  var t,
	    e = {},
	    r = Object.prototype,
	    n = r.hasOwnProperty,
	    o = Object.defineProperty || function (t, e, r) {
	      t[e] = r.value;
	    },
	    i = "function" == typeof Symbol ? Symbol : {},
	    a = i.iterator || "@@iterator",
	    c = i.asyncIterator || "@@asyncIterator",
	    u = i.toStringTag || "@@toStringTag";
	  function define(t, e, r) {
	    return Object.defineProperty(t, e, {
	      value: r,
	      enumerable: !0,
	      configurable: !0,
	      writable: !0
	    }), t[e];
	  }
	  try {
	    define({}, "");
	  } catch (t) {
	    define = function define(t, e, r) {
	      return t[e] = r;
	    };
	  }
	  function wrap(t, e, r, n) {
	    var i = e && e.prototype instanceof Generator ? e : Generator,
	      a = Object.create(i.prototype),
	      c = new Context(n || []);
	    return o(a, "_invoke", {
	      value: makeInvokeMethod(t, r, c)
	    }), a;
	  }
	  function tryCatch(t, e, r) {
	    try {
	      return {
	        type: "normal",
	        arg: t.call(e, r)
	      };
	    } catch (t) {
	      return {
	        type: "throw",
	        arg: t
	      };
	    }
	  }
	  e.wrap = wrap;
	  var h = "suspendedStart",
	    l = "suspendedYield",
	    f = "executing",
	    s = "completed",
	    y = {};
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	  var p = {};
	  define(p, a, function () {
	    return this;
	  });
	  var d = Object.getPrototypeOf,
	    v = d && d(d(values([])));
	  v && v !== r && n.call(v, a) && (p = v);
	  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
	  function defineIteratorMethods(t) {
	    ["next", "throw", "return"].forEach(function (e) {
	      define(t, e, function (t) {
	        return this._invoke(e, t);
	      });
	    });
	  }
	  function AsyncIterator(t, e) {
	    function invoke(r, o, i, a) {
	      var c = tryCatch(t[r], t, o);
	      if ("throw" !== c.type) {
	        var u = c.arg,
	          h = u.value;
	        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
	          invoke("next", t, i, a);
	        }, function (t) {
	          invoke("throw", t, i, a);
	        }) : e.resolve(h).then(function (t) {
	          u.value = t, i(u);
	        }, function (t) {
	          return invoke("throw", t, i, a);
	        });
	      }
	      a(c.arg);
	    }
	    var r;
	    o(this, "_invoke", {
	      value: function value(t, n) {
	        function callInvokeWithMethodAndArg() {
	          return new e(function (e, r) {
	            invoke(t, n, e, r);
	          });
	        }
	        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	      }
	    });
	  }
	  function makeInvokeMethod(e, r, n) {
	    var o = h;
	    return function (i, a) {
	      if (o === f) throw new Error("Generator is already running");
	      if (o === s) {
	        if ("throw" === i) throw a;
	        return {
	          value: t,
	          done: !0
	        };
	      }
	      for (n.method = i, n.arg = a;;) {
	        var c = n.delegate;
	        if (c) {
	          var u = maybeInvokeDelegate(c, n);
	          if (u) {
	            if (u === y) continue;
	            return u;
	          }
	        }
	        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
	          if (o === h) throw o = s, n.arg;
	          n.dispatchException(n.arg);
	        } else "return" === n.method && n.abrupt("return", n.arg);
	        o = f;
	        var p = tryCatch(e, r, n);
	        if ("normal" === p.type) {
	          if (o = n.done ? s : l, p.arg === y) continue;
	          return {
	            value: p.arg,
	            done: n.done
	          };
	        }
	        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
	      }
	    };
	  }
	  function maybeInvokeDelegate(e, r) {
	    var n = r.method,
	      o = e.iterator[n];
	    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
	    var i = tryCatch(o, e.iterator, r.arg);
	    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
	    var a = i.arg;
	    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
	  }
	  function pushTryEntry(t) {
	    var e = {
	      tryLoc: t[0]
	    };
	    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
	  }
	  function resetTryEntry(t) {
	    var e = t.completion || {};
	    e.type = "normal", delete e.arg, t.completion = e;
	  }
	  function Context(t) {
	    this.tryEntries = [{
	      tryLoc: "root"
	    }], t.forEach(pushTryEntry, this), this.reset(!0);
	  }
	  function values(e) {
	    if (e || "" === e) {
	      var r = e[a];
	      if (r) return r.call(e);
	      if ("function" == typeof e.next) return e;
	      if (!isNaN(e.length)) {
	        var o = -1,
	          i = function next() {
	            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
	            return next.value = t, next.done = !0, next;
	          };
	        return i.next = i;
	      }
	    }
	    throw new TypeError(_typeof(e) + " is not iterable");
	  }
	  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
	    value: GeneratorFunctionPrototype,
	    configurable: !0
	  }), o(GeneratorFunctionPrototype, "constructor", {
	    value: GeneratorFunction,
	    configurable: !0
	  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
	    var e = "function" == typeof t && t.constructor;
	    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
	  }, e.mark = function (t) {
	    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
	  }, e.awrap = function (t) {
	    return {
	      __await: t
	    };
	  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
	    return this;
	  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
	    void 0 === i && (i = Promise);
	    var a = new AsyncIterator(wrap(t, r, n, o), i);
	    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
	      return t.done ? t.value : a.next();
	    });
	  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
	    return this;
	  }), define(g, "toString", function () {
	    return "[object Generator]";
	  }), e.keys = function (t) {
	    var e = Object(t),
	      r = [];
	    for (var n in e) r.push(n);
	    return r.reverse(), function next() {
	      for (; r.length;) {
	        var t = r.pop();
	        if (t in e) return next.value = t, next.done = !1, next;
	      }
	      return next.done = !0, next;
	    };
	  }, e.values = values, Context.prototype = {
	    constructor: Context,
	    reset: function reset(e) {
	      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
	    },
	    stop: function stop() {
	      this.done = !0;
	      var t = this.tryEntries[0].completion;
	      if ("throw" === t.type) throw t.arg;
	      return this.rval;
	    },
	    dispatchException: function dispatchException(e) {
	      if (this.done) throw e;
	      var r = this;
	      function handle(n, o) {
	        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
	      }
	      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
	        var i = this.tryEntries[o],
	          a = i.completion;
	        if ("root" === i.tryLoc) return handle("end");
	        if (i.tryLoc <= this.prev) {
	          var c = n.call(i, "catchLoc"),
	            u = n.call(i, "finallyLoc");
	          if (c && u) {
	            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
	            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
	          } else if (c) {
	            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
	          } else {
	            if (!u) throw new Error("try statement without catch or finally");
	            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
	          }
	        }
	      }
	    },
	    abrupt: function abrupt(t, e) {
	      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
	        var o = this.tryEntries[r];
	        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
	          var i = o;
	          break;
	        }
	      }
	      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
	      var a = i ? i.completion : {};
	      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
	    },
	    complete: function complete(t, e) {
	      if ("throw" === t.type) throw t.arg;
	      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
	    },
	    finish: function finish(t) {
	      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
	        var r = this.tryEntries[e];
	        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
	      }
	    },
	    "catch": function _catch(t) {
	      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
	        var r = this.tryEntries[e];
	        if (r.tryLoc === t) {
	          var n = r.completion;
	          if ("throw" === n.type) {
	            var o = n.arg;
	            resetTryEntry(r);
	          }
	          return o;
	        }
	      }
	      throw new Error("illegal catch attempt");
	    },
	    delegateYield: function delegateYield(e, r, n) {
	      return this.delegate = {
	        iterator: values(e),
	        resultName: r,
	        nextLoc: n
	      }, "next" === this.method && (this.arg = t), y;
	    }
	  }, e;
	}
	module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (regeneratorRuntime$1));

var regeneratorRuntimeExports = regeneratorRuntime$1.exports;

// TODO(Babel 8): Remove this file.

var runtime = regeneratorRuntimeExports();
var regenerator = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

var _regeneratorRuntime = /*@__PURE__*/getDefaultExportFromCjs(regenerator);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const t=new WeakMap;function e(t,e){return new Proxy(t,{get:(t,r)=>e(t[r])})}class r{constructor(){this.value=void 0,this.exports=null;}getState(){return this.exports.asyncify_get_state()}assertNoneState(){let t=this.getState();if(0!==t)throw new Error(`Invalid async state ${t}, expected 0.`)}wrapImportFn(t){return (...e)=>{if(2===this.getState())return this.exports.asyncify_stop_rewind(),this.value;this.assertNoneState();let r=t(...e);if(!(s=r)||"object"!=typeof s&&"function"!=typeof s||"function"!=typeof s.then)return r;var s;this.exports.asyncify_start_unwind(16),this.value=r;}}wrapModuleImports(t){return e(t,t=>"function"==typeof t?this.wrapImportFn(t):t)}wrapImports(t){if(void 0!==t)return e(t,(t=Object.create(null))=>this.wrapModuleImports(t))}wrapExportFn(e){let r=t.get(e);return void 0!==r||(r=async(...t)=>{this.assertNoneState();let r=e(...t);for(;1===this.getState();)this.exports.asyncify_stop_unwind(),this.value=await this.value,this.assertNoneState(),this.exports.asyncify_start_rewind(16),r=e();return this.assertNoneState(),r},t.set(e,r)),r}wrapExports(e){let r=Object.create(null);for(let t in e){let s=e[t];"function"!=typeof s||t.startsWith("asyncify_")||(s=this.wrapExportFn(s)),Object.defineProperty(r,t,{enumerable:!0,value:s});}return t.set(e,r),r}init(t,e){const{exports:r}=t,n=r.memory||e.env&&e.env.memory;new Int32Array(n.buffer,16).set([24,1024]),this.exports=this.wrapExports(r),Object.setPrototypeOf(t,s.prototype);}}class s extends WebAssembly.Instance{constructor(t,e){let s=new r;super(t,s.wrapImports(e)),s.init(this,e);}get exports(){return t.get(super.exports)}}async function n(t,e){let s=new r,n=await WebAssembly.instantiate(t,s.wrapImports(e));return s.init(n instanceof WebAssembly.Instance?n:n.instance,e),n}async function a(t,e){let s=new r,n=await WebAssembly.instantiateStreaming(t,s.wrapImports(e));return s.init(n.instance,e),n}Object.defineProperty(s.prototype,"exports",{enumerable:!0});

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

/*
  Copyright 2022-2023 Picovoice Inc.

  You may not use this file except in compliance with the license. A copy of the license is located in the "LICENSE"
  file accompanying this source.

  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
  an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
  specific language governing permissions and limitations under the License.
*/
/**
 * BasePvFile Class
 * This class mocks the file system using in-memory storage.
 */
var PvFile = /*#__PURE__*/function () {
  function PvFile() {
    _classCallCheck(this, PvFile);
    this._path = '';
  }
  /**
   * Getter for file's meta information.
   */
  _createClass(PvFile, [{
    key: "meta",
    get: function get() {
      if (this._meta === undefined) {
        return undefined;
      }
      return Object.assign({
        version: 0
      }, this._meta);
    }
  }, {
    key: "pageSize",
    get: function get() {
      return undefined;
    }
    /**
     * Get the file pointer from the _filePtrs map.
     * @param ptr The pointer to BasePvFile instance to get from the map.
     * @returns BasePvFile returns the current file instance related to ptr.
     */
  }], [{
    key: "getPtr",
    value: function getPtr(ptr) {
      if (PvFile._filePtrs.has(ptr)) {
        return PvFile._filePtrs.get(ptr);
      }
      throw new Error('File instance not found.');
    }
    /**
     * Saves the BasePvFile instance to the map with an associated ptr.
     * @param ptr The file pointer to save as the key.
     * @param instance The BasePvFile instance to save as the value.
     */
  }, {
    key: "setPtr",
    value: function setPtr(ptr, instance) {
      PvFile._filePtrs.set(ptr, instance);
    }
    /**
     * Removes the ptr from the _filePtrs map.
     * @param ptr The file pointer to remove.
     */
  }, {
    key: "removePtr",
    value: function removePtr(ptr) {
      PvFile._filePtrs["delete"](ptr);
    }
  }]);
  return PvFile;
}();
PvFile._filePtrs = new Map();

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Indexed DB configurations
 */
var DB_NAME = 'pv_db';
var PV_FILE_STORE = 'pv_file';
var DB_VERSION = 3;
/**
 * Helper to get IndexedDB.
 */
function getDB() {
  return new Promise(function (resolve, reject) {
    var request = self.indexedDB.open(DB_NAME, DB_VERSION);
    request.onerror = function () {
      reject(request.error);
    };
    request.onsuccess = function () {
      resolve(request.result);
    };
    request.onupgradeneeded = function () {
      if (!request.result.objectStoreNames.contains(PV_FILE_STORE)) {
        request.result.createObjectStore(PV_FILE_STORE);
      }
    };
  });
}
/**
 * Cache Settings
 */
var PvCache = /*#__PURE__*/function () {
  function PvCache() {
    _classCallCheck(this, PvCache);
    this._pos = 0;
    this._data = new Uint8Array();
  }
  _createClass(PvCache, [{
    key: "get",
    value: function get(bytes) {
      if (this._pos >= this._data.length) {
        return undefined;
      }
      var res = this._data.slice(this._pos, this._pos + bytes);
      this._pos += bytes;
      return res;
    }
  }, {
    key: "set",
    value: function set(pos, data) {
      this._pos = pos;
      this._data = data;
    }
  }, {
    key: "clear",
    value: function clear() {
      this._pos = 0;
      this._data = new Uint8Array();
    }
  }]);
  return PvCache;
}();
/**
 * PvFile Class
 * This class mocks the file system using IndexedDB.
 * IndexedDB is REQUIRED.
 */
var PvFileIDB = /*#__PURE__*/function (_PvFile) {
  _inherits(PvFileIDB, _PvFile);
  var _super = _createSuper$1(PvFileIDB);
  /**
   * Constructor of PvFile instance.
   * @param path The path of a file.
   * @param meta The metadata of the file.
   * @param db The db instance currently related to the opened file.
   * @param mode The mode - either readonly or readwrite.
   */
  function PvFileIDB(path, meta, db, mode) {
    var _this;
    _classCallCheck(this, PvFileIDB);
    _this = _super.call(this);
    _this._pageSize = 512 * 1024; // 512KB
    _this._pagePtr = 0;
    _this._pageOffset = 0;
    _this._path = path;
    _this._meta = meta;
    _this._db = db;
    _this._mode = mode;
    _this._cache = new PvCache();
    return _this;
  }
  /**
   * Opens a file and return an instance of PvFile. A file can be opened in readonly or readwrite mode
   * which follows IndexedDB standard of reading and writing values to the db.
   * The file is stored as an Uint8Array separated by pages.
   * NOTE: The key exactly matching the path expects a value of type PvFileMeta.
   * @param path The path of the file to open stored in IndexedDB.
   * @param mode A string, if it contains 'r' in the string, it will open the file in readonly mode, else it
   * will open in readwrite mode.
   * @returns Promise<PvFile> An instance of PvFile.
   * @throws Error if IndexedDB is not supported.
   */
  _createClass(PvFileIDB, [{
    key: "pageSize",
    get: function get() {
      return this._pageSize;
    }
  }, {
    key: "close",
    value:
    /**
     * Closes the db connection. Any other instance function call will not work once
     * the db is closed.
     */
    function close() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this._db.close();
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
    }
    /**
     * Reads a total of 'count' elements, each with a size of 'size' bytes from the current position in the stream.
     * Moves the stream by the amount of elements read.
     * If the last few bytes is smaller than 'size' it will not read (similar to fread) the bytes.
     * @param size The element size.
     * @param count The number of elements to read.
     * @returns Promise<Uint8Array> A Uint8Array with the elements copied to it.
     * @throws Error if file doesn't exist or if EOF.
     */
  }, {
    key: "read",
    value: function read(size, count) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this2 = this;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                if (!_this2.exists()) {
                  reject(new Error("'".concat(_this2._path, "' doesn't exist.")));
                  return;
                }
                if (_this2._isEOF) {
                  var err = new Error("EOF");
                  err.name = "EndOfFile";
                  reject(err);
                  return;
                }
                var copied = 0;
                var maxToCopy = Math.min(size * count, _this2._meta.size);
                var totalElems = maxToCopy - maxToCopy % size;
                var buffer = new Uint8Array(totalElems);
                // check if there's data in cache
                var res = _this2._cache.get(totalElems);
                if (res) {
                  copied += res.length;
                  _this2._pageOffset += res.length;
                  if (_this2._pageOffset === _this2._pageSize) {
                    _this2._pagePtr += 1;
                    _this2._pageOffset = 0;
                  }
                  if (totalElems === copied) {
                    resolve(res);
                    return;
                  }
                  buffer.set(res);
                }
                var keyRange = IDBKeyRange.bound("".concat(_this2._path, "-").concat(PvFileIDB.createPage(_this2._pagePtr)), "".concat(_this2._path, "-").concat(PvFileIDB.createPage(_this2._pagePtr + Math.floor(totalElems / _this2._pageSize) + 1)));
                var store = _this2._store;
                var req = store.openCursor(keyRange);
                req.onsuccess = function () {
                  var _a, _b;
                  var cursor = req.result;
                  if (!cursor || _this2._isEOF) {
                    return;
                  }
                  var toCopy = Math.min(totalElems - copied, cursor.value.length - _this2._pageOffset);
                  buffer.set(cursor.value.slice(_this2._pageOffset, _this2._pageOffset + toCopy), copied);
                  copied += toCopy;
                  _this2._pageOffset += toCopy;
                  if (_this2._pageOffset === _this2._pageSize) {
                    _this2._pagePtr += 1;
                    _this2._pageOffset = 0;
                  }
                  if (copied < totalElems) {
                    cursor["continue"]();
                  } else {
                    if (_this2._pageOffset !== 0) {
                      _this2._cache.set(_this2._pageOffset, cursor.value);
                    } else {
                      _this2._cache.clear();
                    }
                    if ((_a = store.transaction) === null || _a === void 0 ? void 0 : _a.commit) {
                      (_b = store.transaction) === null || _b === void 0 ? void 0 : _b.commit();
                    }
                  }
                };
                store.transaction.onerror = function () {
                  reject(store.transaction.error);
                };
                store.transaction.oncomplete = function () {
                  resolve(buffer.slice(0, copied));
                };
              }));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
    }
    /**
     * Writes an Uint8Array to IndexedDB seperated by pages.
     * @param content The bytes to save.
     * @param version Version of the file.
     */
  }, {
    key: "write",
    value: function write(content) {
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _this3 = this;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", new Promise(function (resolve, reject) {
                return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
                  var _this4 = this;
                  var _a, _b, store, getCurrentPage, last, newContent, newSize, newMeta, pages, i, keyRange;
                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        if (!(this._mode === "readonly")) {
                          _context3.next = 3;
                          break;
                        }
                        reject(new Error("Instance is readonly mode only."));
                        return _context3.abrupt("return");
                      case 3:
                        if (!(typeof version !== "number" && version <= 0)) {
                          _context3.next = 6;
                          break;
                        }
                        reject(new Error("Version should be a positive number"));
                        return _context3.abrupt("return");
                      case 6:
                        store = this._store;
                        getCurrentPage = function getCurrentPage() {
                          return new Promise(function (res) {
                            var req = store.get("".concat(_this4._path, "-").concat(PvFileIDB.createPage(_this4._pagePtr)));
                            req.onsuccess = function () {
                              if (req.result !== undefined) {
                                res(req.result.slice(0, _this4._pageOffset));
                              } else {
                                res(new Uint8Array(0));
                              }
                            };
                          });
                        };
                        _context3.next = 10;
                        return getCurrentPage();
                      case 10:
                        last = _context3.sent;
                        newContent = new Uint8Array(last.length + content.length);
                        newContent.set(last);
                        newContent.set(content, last.length);
                        newSize = this._pagePtr * this._pageSize + newContent.length;
                        newMeta = {
                          size: newSize,
                          numPages: Math.ceil(newSize / this._pageSize),
                          version: version,
                          pageSize: this._pageSize
                        };
                        store.put(newMeta, this._path);
                        pages = Math.ceil(newContent.length / this._pageSize);
                        for (i = 0; i < pages; i++) {
                          store.put(newContent.slice(i * this._pageSize, (i + 1) * this._pageSize), "".concat(this._path, "-").concat(PvFileIDB.createPage(this._pagePtr + i)));
                        }
                        if (this.exists() && newMeta.numPages < this._meta.numPages) {
                          keyRange = IDBKeyRange.bound("".concat(this._path, "-").concat(PvFileIDB.createPage(newMeta.numPages)), "".concat(this._path, "-").concat(PvFileIDB.createPage(this._meta.numPages)), true);
                          store["delete"](keyRange);
                        }
                        if ((_a = store.transaction) === null || _a === void 0 ? void 0 : _a.commit) {
                          (_b = store.transaction) === null || _b === void 0 ? void 0 : _b.commit();
                        }
                        store.transaction.onerror = function () {
                          reject(store.transaction.error);
                        };
                        store.transaction.oncomplete = function () {
                          _this4._meta = newMeta;
                          _this4.seek(0, 2);
                          resolve();
                        };
                      case 23:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3, this);
                }));
              }));
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
    }
    /**
     * Moves the current position in the stream by 'offset' elements at 'whence' position.
     * @param offset The number of bytes to move.
     * @param whence One of:
     *  - 0: moves position from beginning of file.
     *  - 1: moves position from current position in the stream.
     *  - 2: moves position from the last element of the file.
     * @throws Error if file doesn't exist or if EOF.
     */
  }, {
    key: "seek",
    value: function seek(offset, whence) {
      if (!this.exists() && this._mode === "readonly") {
        throw new Error("'".concat(this._path, "' doesn't exist."));
      }
      if (!this.exists()) {
        // This is valid in ISO C but not supported by this current implementation
        throw new Error("'".concat(this._path, "' doesn't exist."));
      }
      if (offset < 0) {
        var err = new Error("EOF");
        err.name = "EndOfFile";
        throw err;
      }
      var newOffset;
      if (whence === 0) {
        newOffset = Math.min(offset, this._meta.size);
      } else if (whence === 1) {
        var currentOffset = this._pageSize * this._pagePtr + this._pageOffset;
        newOffset = Math.min(currentOffset + offset, this._meta.size);
      } else if (whence === 2) {
        newOffset = Math.min(this._meta.size + offset, this._meta.size);
      } else {
        throw new Error("Invalid operation: ".concat(whence, "."));
      }
      this._pageOffset = newOffset % this._pageSize;
      this._pagePtr = Math.floor(newOffset / this._pageSize);
      this._cache.clear();
    }
    /**
     * Returns the number of bytes from the beginning of the file.
     */
  }, {
    key: "tell",
    value: function tell() {
      if (!this.exists()) {
        return -1;
      }
      return this._pagePtr * this._pageSize + this._pageOffset;
    }
    /**
     * Removes a file and any related pages given the path.
     */
  }, {
    key: "remove",
    value: function remove() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
        var _this5 = this;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", new Promise(function (resolve, reject) {
                return __awaiter(_this5, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
                  var _this6 = this;
                  var numPages, keyRange, store, req;
                  return _regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) switch (_context5.prev = _context5.next) {
                      case 0:
                        if (this.exists()) {
                          _context5.next = 3;
                          break;
                        }
                        reject(new Error("ENOENT"));
                        return _context5.abrupt("return");
                      case 3:
                        numPages = this._meta.numPages;
                        keyRange = IDBKeyRange.bound(this._path, "".concat(this._path, "-").concat(PvFileIDB.createPage(numPages)));
                        store = this._store;
                        req = store["delete"](keyRange);
                        req.onerror = function () {
                          reject(req.error);
                        };
                        req.onsuccess = function () {
                          _this6._meta = undefined;
                          _this6._pageOffset = 0;
                          _this6._pagePtr = 0;
                          resolve();
                        };
                      case 9:
                      case "end":
                        return _context5.stop();
                    }
                  }, _callee5, this);
                }));
              }));
            case 1:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
    }
    /**
     * Checks if the following path exists.
     */
  }, {
    key: "exists",
    value: function exists() {
      return this._meta !== undefined;
    }
    /**
     * Checks if the current stream is EOF.
     */
  }, {
    key: "_isEOF",
    get: function get() {
      return this._pagePtr >= this._meta.numPages - 1 && this._pageOffset >= this._meta.size % this._pageSize;
    }
    /**
     * Creates an index which as a key to save page data to IndexedDB.
     * This formats the file into 0000, 0001, 0002 ...
     * @param page The page number to format.
     */
  }, {
    key: "_store",
    get:
    /**
     * Gets a objectStore instance from the PvFile instance.
     */
    function get() {
      return this._db.transaction(PV_FILE_STORE, this._mode).objectStore(PV_FILE_STORE);
    }
  }], [{
    key: "open",
    value: function open(path, mode) {
      var _this7 = this;
      if (!self.indexedDB) {
        var error = new Error("IndexedDB is not supported");
        error.name = "IndexedDBNotSupported";
        throw error;
      }
      return new Promise(function (resolve, reject) {
        return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {
          var db, req, _error2;
          return _regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _context7.prev = 0;
                _context7.next = 3;
                return getDB();
              case 3:
                db = _context7.sent;
                req = db.transaction(PV_FILE_STORE, "readwrite").objectStore(PV_FILE_STORE).get(path);
                req.onerror = function () {
                  reject(req.error);
                };
                req.onsuccess = function () {
                  var meta = req.result;
                  var dbMode = mode.includes('r') ? "readonly" : "readwrite";
                  if (meta === undefined && dbMode === "readonly") {
                    var _error = new Error("'".concat(path, "' doesn't exist."));
                    _error.name = "FileNotExists";
                    reject(_error);
                    return;
                  }
                  var fileIDB = new PvFileIDB(path, meta, db, dbMode);
                  if (mode.includes('a')) {
                    fileIDB.seek(0, 2);
                  }
                  resolve(fileIDB);
                };
                _context7.next = 12;
                break;
              case 9:
                _context7.prev = 9;
                _context7.t0 = _context7["catch"](0);
                if (_context7.t0.name === "InvalidStateError") {
                  _error2 = new Error("IndexedDB is not supported");
                  _error2.name = "IndexedDBNotSupported";
                  reject(_error2);
                } else {
                  reject(_context7.t0);
                }
              case 12:
              case "end":
                return _context7.stop();
            }
          }, _callee7, null, [[0, 9]]);
        }));
      });
    }
  }, {
    key: "createPage",
    value: function createPage(page) {
      return ("00000" + page).slice(-6);
    }
  }]);
  return PvFileIDB;
}(PvFile);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * PvFileMem Class
 * This class mocks the file system using in-memory storage.
 */
var PvFileMem = /*#__PURE__*/function (_PvFile) {
  _inherits(PvFileMem, _PvFile);
  var _super = _createSuper(PvFileMem);
  function PvFileMem(path, meta, db, mode) {
    var _this;
    _classCallCheck(this, PvFileMem);
    _this = _super.call(this);
    _this._pos = 0;
    _this._path = path;
    _this._meta = meta;
    _this._mode = mode;
    return _this;
  }
  _createClass(PvFileMem, [{
    key: "close",
    value: function close() {
      return;
    }
  }, {
    key: "read",
    value: function read(size, count) {
      if (!this.exists()) {
        throw new Error("'".concat(this._path, "' doesn't exist."));
      }
      if (this._isEOF) {
        var err = new Error("EOF");
        err.name = "EndOfFile";
        throw err;
      }
      var toCopy = Math.min(size * count, this._file.length - this._pos);
      var totalElems = toCopy - toCopy % size;
      var buffer = new Uint8Array(totalElems);
      buffer.set(this._file.slice(this._pos, this._pos + totalElems), 0);
      this._pos += totalElems;
      return buffer;
    }
  }, {
    key: "write",
    value: function write(content) {
      var newFile = new Uint8Array(this._pos + content.length);
      if (this._file !== undefined) {
        newFile.set(this._file.slice(0, this._pos));
        newFile.set(content, this._pos);
      } else {
        newFile.set(content);
      }
      this._file = newFile;
      this._pos += content.length;
    }
  }, {
    key: "seek",
    value: function seek(offset, whence) {
      if (!this.exists() && this._mode === "readonly") {
        throw new Error("'".concat(this._path, "' doesn't exist."));
      }
      if (!this.exists()) {
        // This is valid in ISO C but not supported by this current implementation
        throw new Error("'".concat(this._path, "' doesn't exist."));
      }
      if (offset < 0) {
        var err = new Error("EOF");
        err.name = "EndOfFile";
        throw err;
      }
      var newOffset;
      if (whence === 0) {
        newOffset = Math.min(offset, this._file.length);
      } else if (whence === 1) {
        newOffset = Math.min(this._pos + offset, this._file.length);
      } else if (whence === 2) {
        newOffset = Math.min(this._file.length + offset, this._file.length);
      } else {
        throw new Error("Invalid operation: ".concat(whence, "."));
      }
      this._pos = newOffset;
    }
  }, {
    key: "tell",
    value: function tell() {
      if (!this.exists()) {
        return -1;
      }
      return this._pos;
    }
  }, {
    key: "remove",
    value: function remove() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this.exists()) {
                _context.next = 2;
                break;
              }
              throw new Error("ENOENT");
            case 2:
              PvFileMem._memFiles["delete"](this._path);
              this._pos = 0;
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "exists",
    value: function exists() {
      return this._file !== undefined;
    }
  }, {
    key: "_isEOF",
    get: function get() {
      return this._pos >= this._file.length;
    }
  }, {
    key: "_file",
    get: function get() {
      return PvFileMem._memFiles.get(this._path);
    },
    set: function set(content) {
      PvFileMem._memFiles.set(this._path, content);
    }
  }], [{
    key: "open",
    value: function open(path, mode) {
      var file = PvFileMem._memFiles.get(path);
      var dbMode = mode.includes('r') ? "readonly" : "readwrite";
      if (file === undefined && dbMode === "readonly") {
        var error = new Error("'".concat(path, "' doesn't exist."));
        error.name = "FileNotExists";
        throw error;
      }
      var fileMem = new PvFileMem(path, undefined, undefined, dbMode);
      if (mode.includes('a')) {
        fileMem.seek(0, 2);
      }
      return fileMem;
    }
  }]);
  return PvFileMem;
}(PvFile);
PvFileMem._memFiles = new Map();

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }
function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * Cast a signed address to unsigned address.
 *
 * @param address The address to cast to unsigned address.
 */
function unsignedAddress(address) {
  if (address < 0) {
    return address >>> 0;
  }
  return address;
}
/**
 * Convert a null terminated phrase stored inside an array buffer to a string
 *
 * @param arrayBuffer input array buffer
 * @param indexStart the index at which the phrase is stored
 * @return retrieved string
 */
function arrayBufferToStringAtIndex(arrayBuffer, indexStart) {
  var indexEnd = indexStart;
  while (arrayBuffer[indexEnd] !== 0) {
    indexEnd++;
  }
  var utf8decoder = new TextDecoder('utf-8');
  return utf8decoder.decode(arrayBuffer.slice(indexStart, indexEnd));
}
/**
 * Decode a base64 string and stored it in a Uint8Array array
 *
 * @param base64String input base64 string
 * @return decoded array
 */
function base64ToUint8Array(base64String) {
  var base64StringDecoded = atob(base64String);
  var binaryArray = new Uint8Array(base64StringDecoded.length);
  for (var i = 0; i < base64StringDecoded.length; i++) {
    binaryArray[i] = base64StringDecoded.charCodeAt(i);
  }
  return binaryArray;
}
/**
 * Encode an ArrayBuffer array to base64 string
 *
 * @param arrayBuffer input array
 * @param size size of the phrase to be encoded
 * @param index the index at which the phrase is stored
 * @return base64 string
 */
function arrayBufferToBase64AtIndex(arrayBuffer, size, index) {
  var binary = '';
  for (var i = 0; i < size; i++) {
    // @ts-ignore
    binary += String.fromCharCode(arrayBuffer[index + i]);
  }
  return btoa(binary);
}
/**
 * Convert a string header to JS object
 *
 * @param stringHeader input string in json format
 * @return retrieved object
 */
// eslint-disable-next-line
function stringHeaderToObject(stringHeader) {
  var objectHeader = {};
  var _iterator = _createForOfIteratorHelper(stringHeader.split('\r\n')),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;
      var keyValuePair = property.split(': ');
      if (keyValuePair[0] !== '') {
        // @ts-ignore
        objectHeader[keyValuePair[0]] = keyValuePair[1];
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return objectHeader;
}
/**
 * A wrapper to fetch that also supports timeout
 *
 * @param uri the URL of the resource
 * @param options other options related to fetch
 * @param time timeout value
 * @return received response
 */
function fetchWithTimeout(uri) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5000;
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var controller, config, timeout, response;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          controller = new AbortController();
          config = Object.assign(Object.assign({}, options), {
            signal: controller.signal
          });
          timeout = setTimeout(function () {
            controller.abort();
          }, time);
          _context.next = 5;
          return fetch(uri, config);
        case 5:
          response = _context.sent;
          clearTimeout(timeout);
          return _context.abrupt("return", response);
        case 8:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
}
/**
 * Checking whether the given AccessKey is valid
 *
 * @return true if the AccessKey is valid, false if not
 */
function isAccessKeyValid(accessKey) {
  if (typeof accessKey !== 'string') {
    return false;
  }
  var accessKeyCleaned = accessKey.trim();
  if (accessKeyCleaned === '') {
    return false;
  }
  try {
    return btoa(atob(accessKeyCleaned)) === accessKeyCleaned;
  } catch (err) {
    return false;
  }
}
/**
 * Opens the file given the path and mode.
 * @returns PvFile instance.
 */
function open(path, mode) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    var error;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          _context2.next = 3;
          return PvFileIDB.open(path, mode);
        case 3:
          return _context2.abrupt("return", _context2.sent);
        case 6:
          _context2.prev = 6;
          _context2.t0 = _context2["catch"](0);
          if (_context2.t0.name === 'IndexedDBNotSupported') {
            // eslint-disable-next-line no-console
            console.warn('IndexedDB is not supported. Fallback to in-memory storage.');
          } else if (_context2.t0.name !== 'FileNotExists') {
            // eslint-disable-next-line no-console
            console.warn("Unable to access IndexedDB (".concat(_context2.t0.toString(), "). Fallback to in-memory storage."));
          }
          if (!(
          // @ts-ignore
          typeof WorkerGlobalScope !== 'undefined' &&
          // @ts-ignore
          self instanceof WorkerGlobalScope)) {
            _context2.next = 16;
            break;
          }
          if (!(_context2.t0.name === 'FileNotExists')) {
            _context2.next = 12;
            break;
          }
          throw _context2.t0;
        case 12:
          // eslint-disable-next-line no-console
          console.error('In-memory storage cannot be used inside a worker.');
          error = new Error("Failed to start PvFile: ".concat(_context2.t0.toString()));
          error.name = 'PvFileNotSupported';
          throw error;
        case 16:
          return _context2.abrupt("return", PvFileMem.open(path, mode));
        case 17:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[0, 6]]);
  }));
}
/**
 * PvFile helper.
 * Write modelBase64 to modelPath depending on options forceWrite and version.
 */
function fromBase64(modelPath, modelBase64, forceWrite, version) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
    var pvFile;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return open(modelPath, 'w');
        case 2:
          pvFile = _context3.sent;
          if (!(forceWrite || pvFile.meta === undefined || version > pvFile.meta.version || pvFile.meta.pageSize !== pvFile.pageSize)) {
            _context3.next = 6;
            break;
          }
          _context3.next = 6;
          return pvFile.write(base64ToUint8Array(modelBase64), version);
        case 6:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
}
var BACKOFF_CAP_MILLISECONDS = 5000;
var BACKOFF_START_MILLISECONDS = 2;
/**
 * PvFile helper.
 * Write publicPath's model to modelPath depending on options forceWrite and version.
 */
function fromPublicDirectory(modelPath, publicPath, forceWrite, version, numFetchReties) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
    var pvFile, waitTimeMilliseconds, delay, numAttemptsLeft, error, response, data, responseText;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return open(modelPath, 'w');
        case 2:
          pvFile = _context4.sent;
          if (!(forceWrite || pvFile.meta === undefined || version > pvFile.meta.version || pvFile.meta.pageSize !== pvFile.pageSize)) {
            _context4.next = 43;
            break;
          }
          if (!(numFetchReties < 0)) {
            _context4.next = 6;
            break;
          }
          throw Error('numFetchRetries must be a positive number');
        case 6:
          waitTimeMilliseconds = BACKOFF_START_MILLISECONDS;
          delay = function delay(delayMilliseconds) {
            return new Promise(function (resolve) {
              setTimeout(resolve, delayMilliseconds);
            });
          };
          numAttemptsLeft = numFetchReties + 1;
          error = null;
        case 10:
          if (!(numAttemptsLeft > 0)) {
            _context4.next = 38;
            break;
          }
          error = null;
          _context4.prev = 12;
          _context4.next = 15;
          return fetch(publicPath, {
            cache: 'no-cache'
          });
        case 15:
          response = _context4.sent;
          if (!response.ok) {
            _context4.next = 23;
            break;
          }
          _context4.next = 19;
          return response.arrayBuffer();
        case 19:
          data = _context4.sent;
          _context4.next = 22;
          return pvFile.write(new Uint8Array(data), version);
        case 22:
          return _context4.abrupt("return");
        case 23:
          _context4.next = 25;
          return response.text();
        case 25:
          responseText = _context4.sent;
          error = new Error("Error response returned while fetching model from '".concat(publicPath, "': ").concat(responseText));
          _context4.next = 32;
          break;
        case 29:
          _context4.prev = 29;
          _context4.t0 = _context4["catch"](12);
          error = new Error("Failed to fetch model from '".concat(publicPath, "': ").concat(_context4.t0.message));
        case 32:
          numAttemptsLeft--;
          _context4.next = 35;
          return delay(waitTimeMilliseconds);
        case 35:
          waitTimeMilliseconds = Math.min(BACKOFF_CAP_MILLISECONDS, waitTimeMilliseconds * BACKOFF_START_MILLISECONDS);
          _context4.next = 10;
          break;
        case 38:
          if (!(error !== null)) {
            _context4.next = 42;
            break;
          }
          throw error;
        case 42:
          throw new Error("Unexpected error encountered while fetching model from '".concat(publicPath, "'"));
        case 43:
        case "end":
          return _context4.stop();
      }
    }, _callee4, null, [[12, 29]]);
  }));
}
/**
 * Takes a Picovoice model file and either decodes it from base64 or fetches
 * it from the public directory. Saves the result to storage on version increase or
 * if forceWrite is enabled.
 */
function loadModel(model) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
    var base64, publicPath, customWritePath, _model$forceWrite, forceWrite, _model$version, version, _model$numFetchRetrie, numFetchRetries;
    return _regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          if (!(model === undefined || model === null)) {
            _context5.next = 2;
            break;
          }
          throw new Error('The model is undefined / empty');
        case 2:
          base64 = model.base64, publicPath = model.publicPath, customWritePath = model.customWritePath, _model$forceWrite = model.forceWrite, forceWrite = _model$forceWrite === void 0 ? false : _model$forceWrite, _model$version = model.version, version = _model$version === void 0 ? 1 : _model$version, _model$numFetchRetrie = model.numFetchRetries, numFetchRetries = _model$numFetchRetrie === void 0 ? 0 : _model$numFetchRetrie;
          if (!(customWritePath === undefined || customWritePath === null)) {
            _context5.next = 5;
            break;
          }
          throw new Error('The customWritePath of the provided model is undefined / empty');
        case 5:
          if (!(base64 !== undefined && base64 !== null)) {
            _context5.next = 10;
            break;
          }
          _context5.next = 8;
          return fromBase64(customWritePath, base64, forceWrite, version);
        case 8:
          _context5.next = 16;
          break;
        case 10:
          if (!(publicPath !== undefined && publicPath !== null)) {
            _context5.next = 15;
            break;
          }
          _context5.next = 13;
          return fromPublicDirectory(customWritePath, publicPath, forceWrite, version, numFetchRetries);
        case 13:
          _context5.next = 16;
          break;
        case 15:
          throw new Error("The provided model doesn't contain a valid publicPath or base64 value");
        case 16:
          return _context5.abrupt("return", customWritePath);
        case 17:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
}

/*
  Copyright 2022 Picovoice Inc.

  You may not use this file except in compliance with the license. A copy of the license is located in the "LICENSE"
  file accompanying this source.

  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
  an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
  specific language governing permissions and limitations under the License.
*/
/* eslint camelcase: 0, arrow-body-style: 0, @typescript-eslint/no-unused-vars: 0, @typescript-eslint/explicit-module-boundary-types: 0 */
var wasiSnapshotPreview1Emulator = {
  args_get: function args_get(input) {
    return 0;
  },
  args_sizes_get: function args_sizes_get(input) {
    return 0;
  },
  environ_get: function environ_get(input) {
    return 0;
  },
  environ_sizes_get: function environ_sizes_get(input) {
    return 0;
  },
  clock_res_get: function clock_res_get(input) {
    return 0;
  },
  clock_time_get: function clock_time_get(input) {
    return 0;
  },
  fd_advise: function fd_advise(input) {
    return 0;
  },
  fd_allocate: function fd_allocate(input) {
    return 0;
  },
  fd_close: function fd_close(input) {
    return 0;
  },
  fd_datasync: function fd_datasync(input) {
    return 0;
  },
  fd_fdstat_get: function fd_fdstat_get(input) {
    return 0;
  },
  fd_fdstat_set_flags: function fd_fdstat_set_flags(input) {
    return 0;
  },
  fd_fdstat_set_rights: function fd_fdstat_set_rights(input) {
    return 0;
  },
  fd_filestat_get: function fd_filestat_get(input) {
    return 0;
  },
  fd_filestat_set_size: function fd_filestat_set_size(input) {
    return 0;
  },
  fd_filestat_set_times: function fd_filestat_set_times(input) {
    return 0;
  },
  fd_pread: function fd_pread(input) {
    return 0;
  },
  fd_prestat_get: function fd_prestat_get(input) {
    return 0;
  },
  fd_prestat_dir_name: function fd_prestat_dir_name(input) {
    return 0;
  },
  fd_pwrite: function fd_pwrite(input) {
    return 0;
  },
  fd_read: function fd_read(input) {
    return 0;
  },
  fd_readdir: function fd_readdir(input) {
    return 0;
  },
  fd_renumber: function fd_renumber(input) {
    return 0;
  },
  fd_seek: function fd_seek(input) {
    return 0;
  },
  fd_sync: function fd_sync(input) {
    return 0;
  },
  fd_tell: function fd_tell(input) {
    return 0;
  },
  fd_write: function fd_write(input) {
    return 0;
  },
  path_create_directory: function path_create_directory(input) {
    return 0;
  },
  path_filestat_get: function path_filestat_get(input) {
    return 0;
  },
  path_filestat_set_times: function path_filestat_set_times(input) {
    return 0;
  },
  path_link: function path_link(input) {
    return 0;
  },
  path_open: function path_open(input) {
    return 0;
  },
  path_readlink: function path_readlink(input) {
    return 0;
  },
  path_remove_directory: function path_remove_directory(input) {
    return 0;
  },
  path_rename: function path_rename(input) {
    return 0;
  },
  path_symlink: function path_symlink(input) {
    return 0;
  },
  path_unlink_file: function path_unlink_file(input) {
    return 0;
  },
  poll_oneoff: function poll_oneoff(input) {
    return 0;
  },
  proc_exit: function proc_exit(input) {
    return 0;
  },
  proc_raise: function proc_raise(input) {
    return 0;
  },
  sched_yield: function sched_yield(input) {
    return 0;
  },
  random_get: function random_get(input) {
    return 0;
  },
  sock_recv: function sock_recv(input) {
    return 0;
  },
  sock_send: function sock_send(input) {
    return 0;
  },
  sock_shutdown: function sock_shutdown(input) {
    return 0;
  }
};

/**
 * Imports and Exports functions required for WASM.
 *
 * @param memory Initialized WebAssembly memory object.
 * @param wasm The wasm file in base64 string or stream to public path (i.e. fetch("file.wasm")) to initialize.
 * @param pvError The PvError object to store error details.
 * @param additionalImports Extra WASM imports.
 * @param wasiImports Additional WASI imports.
 * @returns An object containing the exported functions from WASM.
 */
function buildWasm(memory, wasm, pvError) {
  var additionalImports = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var wasiImports = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {
    var setInt, alignedAlloc, pvConsoleLogWasm, pvAssertWasm, pvTimeWasm, pvHttpsRequestWasm, pvGetBrowserInfo, pvGetOriginInfo, pvFileOpenWasm, pvFileCloseWasm, pvFileReadWasm, pvFileWriteWasm, pvFileSeekWasm, pvFileTellWasm, pvFileRemoveWasm, pvSleepWasm, importObject, instance, response, data, wasmCodeArray, aligned_alloc;
    return _regeneratorRuntime.wrap(function _callee11$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          setInt = function setInt(address, value) {
            var memoryBufferInt32 = new Int32Array(memory.buffer);
            memoryBufferInt32[address / Int32Array.BYTES_PER_ELEMENT] = value;
          };
          alignedAlloc = function alignedAlloc(alignment, size) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
              var pointer;
              return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return aligned_alloc(alignment, size);
                  case 2:
                    pointer = _context.sent;
                    return _context.abrupt("return", unsignedAddress(pointer));
                  case 4:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
          };
          pvConsoleLogWasm = function pvConsoleLogWasm(index) {
            index = unsignedAddress(index);
            var memoryBufferUint8 = new Uint8Array(memory.buffer);
            // eslint-disable-next-line no-console
            console.log(arrayBufferToStringAtIndex(memoryBufferUint8, index));
          };
          pvAssertWasm = function pvAssertWasm(expr, line, fileNameAddress) {
            fileNameAddress = unsignedAddress(fileNameAddress);
            var memoryBufferUint8 = new Uint8Array(memory.buffer);
            if (expr === 0) {
              var fileName = arrayBufferToStringAtIndex(memoryBufferUint8, fileNameAddress);
              throw new Error("assertion failed at line ".concat(line, " in \"").concat(fileName, "\""));
            }
          };
          pvTimeWasm = function pvTimeWasm() {
            return Date.now() / 1000;
          };
          pvHttpsRequestWasm = function pvHttpsRequestWasm(httpMethodAddress, serverNameAddress, endpointAddress, headerAddress, bodyAddress, timeoutMs, responseAddressAddress, responseSizeAddress, responseCodeAddress) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
              var memoryBufferUint8, httpMethod, serverName, endpoint, header, body, headerObject, options, response, responseText, statusCode, responseAddress, i;
              return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    httpMethodAddress = unsignedAddress(httpMethodAddress);
                    serverNameAddress = unsignedAddress(serverNameAddress);
                    endpointAddress = unsignedAddress(endpointAddress);
                    headerAddress = unsignedAddress(headerAddress);
                    bodyAddress = unsignedAddress(bodyAddress);
                    responseAddressAddress = unsignedAddress(responseAddressAddress);
                    responseSizeAddress = unsignedAddress(responseSizeAddress);
                    responseCodeAddress = unsignedAddress(responseCodeAddress);
                    memoryBufferUint8 = new Uint8Array(memory.buffer);
                    httpMethod = arrayBufferToStringAtIndex(memoryBufferUint8, httpMethodAddress);
                    serverName = arrayBufferToStringAtIndex(memoryBufferUint8, serverNameAddress);
                    endpoint = arrayBufferToStringAtIndex(memoryBufferUint8, endpointAddress);
                    header = arrayBufferToStringAtIndex(memoryBufferUint8, headerAddress);
                    body = arrayBufferToStringAtIndex(memoryBufferUint8, bodyAddress);
                    headerObject = stringHeaderToObject(header);
                    options = {
                      method: httpMethod
                    };
                    if (body.length > 0) {
                      options.body = body;
                    }
                    if (Object.keys(headerObject).length > 0) {
                      options.headers = headerObject;
                    }
                    _context2.prev = 18;
                    _context2.next = 21;
                    return fetchWithTimeout('https://' + serverName + endpoint, options, timeoutMs);
                  case 21:
                    response = _context2.sent;
                    statusCode = response.status;
                    _context2.next = 29;
                    break;
                  case 25:
                    _context2.prev = 25;
                    _context2.t0 = _context2["catch"](18);
                    pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvHttpsRequestWasm', "Failed to fetch: ".concat(_context2.t0));
                    return _context2.abrupt("return");
                  case 29:
                    _context2.prev = 29;
                    _context2.next = 32;
                    return response.text();
                  case 32:
                    responseText = _context2.sent;
                    _context2.next = 39;
                    break;
                  case 35:
                    _context2.prev = 35;
                    _context2.t1 = _context2["catch"](29);
                    pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvHttpsRequestWasm', "Failed to get response text: ".concat(_context2.t1));
                    return _context2.abrupt("return");
                  case 39:
                    _context2.next = 41;
                    return alignedAlloc(Int8Array.BYTES_PER_ELEMENT, (responseText.length + 1) * Int8Array.BYTES_PER_ELEMENT);
                  case 41:
                    responseAddress = _context2.sent;
                    if (!(responseAddress === 0)) {
                      _context2.next = 46;
                      break;
                    }
                    pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvMallocError', 'pvHttpsRequestWasm: cannot allocate memory for response');
                    setInt(responseAddressAddress, 0);
                    return _context2.abrupt("return");
                  case 46:
                    setInt(responseSizeAddress, responseText.length + 1);
                    setInt(responseAddressAddress, responseAddress);
                    for (i = 0; i < responseText.length; i++) {
                      memoryBufferUint8[responseAddress + i] = responseText.charCodeAt(i);
                    }
                    memoryBufferUint8[responseAddress + responseText.length] = 0;
                    setInt(responseCodeAddress, statusCode);
                  case 51:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2, null, [[18, 25], [29, 35]]);
            }));
          };
          pvGetBrowserInfo = function pvGetBrowserInfo(browserInfoAddressAddress) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
              var memoryBufferUint8, userAgent, browserInfoAddress, i;
              return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) switch (_context3.prev = _context3.next) {
                  case 0:
                    browserInfoAddressAddress = unsignedAddress(browserInfoAddressAddress);
                    memoryBufferUint8 = new Uint8Array(memory.buffer);
                    userAgent = navigator.userAgent !== undefined ? navigator.userAgent : 'unknown'; // eslint-disable-next-line
                    _context3.next = 5;
                    return alignedAlloc(Uint8Array.BYTES_PER_ELEMENT, (userAgent.length + 1) * Uint8Array.BYTES_PER_ELEMENT);
                  case 5:
                    browserInfoAddress = _context3.sent;
                    if (!(browserInfoAddress === 0)) {
                      _context3.next = 10;
                      break;
                    }
                    pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvMallocError', 'pvGetBrowserInfo: cannot allocate memory for browser info');
                    setInt(browserInfoAddressAddress, 0);
                    return _context3.abrupt("return");
                  case 10:
                    setInt(browserInfoAddressAddress, browserInfoAddress);
                    for (i = 0; i < userAgent.length; i++) {
                      memoryBufferUint8[browserInfoAddress + i] = userAgent.charCodeAt(i);
                    }
                    memoryBufferUint8[browserInfoAddress + userAgent.length] = 0;
                  case 13:
                  case "end":
                    return _context3.stop();
                }
              }, _callee3);
            }));
          };
          pvGetOriginInfo = function pvGetOriginInfo(originInfoAddressAddress) {
            var _a;
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
              var memoryBufferUint8, origin, hostname, originInfoAddress, i;
              return _regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    originInfoAddressAddress = unsignedAddress(originInfoAddressAddress);
                    memoryBufferUint8 = new Uint8Array(memory.buffer);
                    origin = (_a = self.origin) !== null && _a !== void 0 ? _a : self.location.origin;
                    hostname = new URL(origin).hostname; // eslint-disable-next-line
                    _context4.next = 6;
                    return alignedAlloc(Uint8Array.BYTES_PER_ELEMENT, (hostname.length + 1) * Uint8Array.BYTES_PER_ELEMENT);
                  case 6:
                    originInfoAddress = _context4.sent;
                    if (!(originInfoAddress === 0)) {
                      _context4.next = 11;
                      break;
                    }
                    pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvMallocError', 'pvGetOriginInfo: cannot allocate memory for origin info');
                    setInt(originInfoAddressAddress, 0);
                    return _context4.abrupt("return");
                  case 11:
                    setInt(originInfoAddressAddress, originInfoAddress);
                    for (i = 0; i < hostname.length; i++) {
                      memoryBufferUint8[originInfoAddress + i] = hostname.charCodeAt(i);
                    }
                    memoryBufferUint8[originInfoAddress + hostname.length] = 0;
                  case 14:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4);
            }));
          };
          pvFileOpenWasm = function pvFileOpenWasm(fileAddress, pathAddress, modeAddress, statusAddress) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
              var memoryBufferUint8, path, mode, file;
              return _regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    fileAddress = unsignedAddress(fileAddress);
                    pathAddress = unsignedAddress(pathAddress);
                    modeAddress = unsignedAddress(modeAddress);
                    statusAddress = unsignedAddress(statusAddress);
                    memoryBufferUint8 = new Uint8Array(memory.buffer);
                    path = arrayBufferToStringAtIndex(memoryBufferUint8, pathAddress);
                    mode = arrayBufferToStringAtIndex(memoryBufferUint8, modeAddress);
                    _context5.prev = 7;
                    _context5.next = 10;
                    return open(path, mode);
                  case 10:
                    file = _context5.sent;
                    PvFile.setPtr(fileAddress, file);
                    setInt(statusAddress, 0);
                    _context5.next = 19;
                    break;
                  case 15:
                    _context5.prev = 15;
                    _context5.t0 = _context5["catch"](7);
                    if (_context5.t0.name !== 'FileNotExists') {
                      pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvFileOpenWasm', _context5.t0);
                    }
                    setInt(statusAddress, -1);
                  case 19:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5, null, [[7, 15]]);
            }));
          };
          pvFileCloseWasm = function pvFileCloseWasm(fileAddress, statusAddress) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
              var file;
              return _regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) switch (_context6.prev = _context6.next) {
                  case 0:
                    fileAddress = unsignedAddress(fileAddress);
                    statusAddress = unsignedAddress(statusAddress);
                    _context6.prev = 2;
                    _context6.next = 5;
                    return PvFile.getPtr(fileAddress);
                  case 5:
                    file = _context6.sent;
                    _context6.next = 8;
                    return file.close();
                  case 8:
                    setInt(statusAddress, 0);
                    _context6.next = 15;
                    break;
                  case 11:
                    _context6.prev = 11;
                    _context6.t0 = _context6["catch"](2);
                    pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvFileCloseWasm', _context6.t0);
                    setInt(statusAddress, -1);
                  case 15:
                  case "end":
                    return _context6.stop();
                }
              }, _callee6, null, [[2, 11]]);
            }));
          };
          pvFileReadWasm = function pvFileReadWasm(fileAddress, contentAddress, size, count, numReadAddress) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {
              var memoryBufferUint8, file, content;
              return _regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) switch (_context7.prev = _context7.next) {
                  case 0:
                    fileAddress = unsignedAddress(fileAddress);
                    contentAddress = unsignedAddress(contentAddress);
                    numReadAddress = unsignedAddress(numReadAddress);
                    memoryBufferUint8 = new Uint8Array(memory.buffer);
                    _context7.prev = 4;
                    file = PvFile.getPtr(fileAddress);
                    _context7.next = 8;
                    return file.read(size, count);
                  case 8:
                    content = _context7.sent;
                    memoryBufferUint8.set(content, unsignedAddress(contentAddress));
                    setInt(numReadAddress, content.length / size);
                    _context7.next = 17;
                    break;
                  case 13:
                    _context7.prev = 13;
                    _context7.t0 = _context7["catch"](4);
                    pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvFileReadWasm', _context7.t0);
                    setInt(numReadAddress, -1);
                  case 17:
                  case "end":
                    return _context7.stop();
                }
              }, _callee7, null, [[4, 13]]);
            }));
          };
          pvFileWriteWasm = function pvFileWriteWasm(fileAddress, contentAddress, size, count, numWriteAddress) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {
              var memoryBufferUint8, file, content;
              return _regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) switch (_context8.prev = _context8.next) {
                  case 0:
                    fileAddress = unsignedAddress(fileAddress);
                    contentAddress = unsignedAddress(contentAddress);
                    numWriteAddress = unsignedAddress(numWriteAddress);
                    memoryBufferUint8 = new Uint8Array(memory.buffer);
                    _context8.prev = 4;
                    file = PvFile.getPtr(fileAddress);
                    content = new Uint8Array(size * count);
                    content.set(memoryBufferUint8.slice(unsignedAddress(contentAddress), unsignedAddress(contentAddress) + size * count), 0);
                    _context8.next = 10;
                    return file.write(content);
                  case 10:
                    setInt(numWriteAddress, content.length / size);
                    _context8.next = 17;
                    break;
                  case 13:
                    _context8.prev = 13;
                    _context8.t0 = _context8["catch"](4);
                    pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvFileWriteWasm', _context8.t0);
                    setInt(numWriteAddress, -1);
                  case 17:
                  case "end":
                    return _context8.stop();
                }
              }, _callee8, null, [[4, 13]]);
            }));
          };
          pvFileSeekWasm = function pvFileSeekWasm(fileAddress, offset, whence, statusAddress) {
            fileAddress = unsignedAddress(fileAddress);
            statusAddress = unsignedAddress(statusAddress);
            try {
              var file = PvFile.getPtr(fileAddress);
              file.seek(offset, whence);
              setInt(statusAddress, 0);
            } catch (e) {
              pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvFileSeekWasm', e);
              setInt(statusAddress, -1);
            }
          };
          pvFileTellWasm = function pvFileTellWasm(fileAddress, offsetAddress) {
            fileAddress = unsignedAddress(fileAddress);
            offsetAddress = unsignedAddress(offsetAddress);
            try {
              var file = PvFile.getPtr(fileAddress);
              setInt(offsetAddress, file.tell());
            } catch (e) {
              pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvFileTellWasm', e);
              setInt(offsetAddress, -1);
            }
          };
          pvFileRemoveWasm = function pvFileRemoveWasm(pathAddress, statusAddress) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
              var memoryBufferUint8, path, file;
              return _regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) switch (_context9.prev = _context9.next) {
                  case 0:
                    pathAddress = unsignedAddress(pathAddress);
                    statusAddress = unsignedAddress(statusAddress);
                    memoryBufferUint8 = new Uint8Array(memory.buffer);
                    path = arrayBufferToStringAtIndex(memoryBufferUint8, pathAddress);
                    _context9.prev = 4;
                    _context9.next = 7;
                    return open(path, 'w');
                  case 7:
                    file = _context9.sent;
                    _context9.next = 10;
                    return file.remove();
                  case 10:
                    setInt(statusAddress, 0);
                    _context9.next = 17;
                    break;
                  case 13:
                    _context9.prev = 13;
                    _context9.t0 = _context9["catch"](4);
                    pvError === null || pvError === void 0 ? void 0 : pvError.addError('pvFileRemoveWasm', _context9.t0);
                    setInt(statusAddress, -1);
                  case 17:
                  case "end":
                    return _context9.stop();
                }
              }, _callee9, null, [[4, 13]]);
            }));
          };
          pvSleepWasm = function pvSleepWasm(ms) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {
              return _regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) switch (_context10.prev = _context10.next) {
                  case 0:
                    return _context10.abrupt("return", new Promise(function (resolve) {
                      setTimeout(function () {
                        resolve(null);
                      }, ms);
                    }));
                  case 1:
                  case "end":
                    return _context10.stop();
                }
              }, _callee10);
            }));
          };
          importObject = {
            // eslint-disable-next-line camelcase
            wasi_snapshot_preview1: wasiSnapshotPreview1Emulator,
            env: Object.assign({
              memory: memory,
              pv_console_log_wasm: pvConsoleLogWasm,
              pv_assert_wasm: pvAssertWasm,
              pv_time_wasm: pvTimeWasm,
              pv_https_request_wasm: pvHttpsRequestWasm,
              pv_get_browser_info: pvGetBrowserInfo,
              pv_get_origin_info: pvGetOriginInfo,
              pv_file_open_wasm: pvFileOpenWasm,
              pv_file_close_wasm: pvFileCloseWasm,
              pv_file_read_wasm: pvFileReadWasm,
              pv_file_write_wasm: pvFileWriteWasm,
              pv_file_seek_wasm: pvFileSeekWasm,
              pv_file_tell_wasm: pvFileTellWasm,
              pv_file_remove_wasm: pvFileRemoveWasm,
              pv_sleep_wasm: pvSleepWasm
            }, additionalImports),
            wasi: Object.assign({}, wasiImports)
          };
          if (!(wasm instanceof Promise)) {
            _context11.next = 35;
            break;
          }
          if (!a) {
            _context11.next = 24;
            break;
          }
          _context11.next = 21;
          return a(wasm, importObject);
        case 21:
          instance = _context11.sent.instance;
          _context11.next = 33;
          break;
        case 24:
          _context11.next = 26;
          return wasm;
        case 26:
          response = _context11.sent;
          _context11.next = 29;
          return response.arrayBuffer();
        case 29:
          data = _context11.sent;
          _context11.next = 32;
          return n(new Uint8Array(data), importObject);
        case 32:
          instance = _context11.sent.instance;
        case 33:
          _context11.next = 39;
          break;
        case 35:
          wasmCodeArray = base64ToUint8Array(wasm);
          _context11.next = 38;
          return n(wasmCodeArray, importObject);
        case 38:
          instance = _context11.sent.instance;
        case 39:
          aligned_alloc = instance.exports.aligned_alloc;
          return _context11.abrupt("return", Object.assign(Object.assign({}, instance.exports), {
            aligned_alloc: alignedAlloc
          }));
        case 41:
        case "end":
          return _context11.stop();
      }
    }, _callee11);
  }));
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

/*
  Copyright 2023 Picovoice Inc.

  You may not use this file except in compliance with the license. A copy of the license is located in the "LICENSE"
  file accompanying this source.

  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
  an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
  specific language governing permissions and limitations under the License.
*/
var PvError = /*#__PURE__*/function () {
  function PvError() {
    _classCallCheck(this, PvError);
    this._maxNumErrors = 10;
    this._errors = [];
    this._lastError = new Error('null');
  }
  /**
   * Store an error with a key and message.
   */
  _createClass(PvError, [{
    key: "addError",
    value: function addError(key, error) {
      this._lastError = error instanceof Error ? error : new Error(error);
      if (this._errors.length >= this._maxNumErrors) {
        this._errors.shift();
      }
      if (error instanceof Error) {
        this._errors.push({
          key: key,
          message: error.toString()
        });
      } else {
        this._errors.push({
          key: key,
          message: JSON.stringify(error)
        });
      }
    }
    /**
     * Get all recent error messages. Cleans up error list.
     */
  }, {
    key: "getErrors",
    value: function getErrors() {
      var errors = _toConsumableArray(this._errors);
      this._errors = [];
      return errors;
    }
    /**
     * Get errors formatted into a string.
     */
  }, {
    key: "getErrorString",
    value: function getErrorString() {
      return this.getErrors().map(function (_ref) {
        var key = _ref.key,
          message = _ref.message;
        return "'".concat(key, "' failed with: ").concat(message, ".");
      }).join('\n');
    }
    /**
     * Returns the last error message added to the object.
     */
  }, {
    key: "getLastError",
    value: function getLastError() {
      return this._lastError;
    }
    /**
     * Sets the maximum number of errors it can store.
     */
  }, {
    key: "setMaxErrorNum",
    value: function setMaxErrorNum(num) {
      this._maxNumErrors = num;
    }
  }]);
  return PvError;
}();

/*
  Copyright 2022-2023 Picovoice Inc.

  You may not use this file except in compliance with the license. A copy of the license is located in the "LICENSE"
  file accompanying this source.

  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
  an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
  specific language governing permissions and limitations under the License.
*/
var dbConfig = {
  DB_NAME: DB_NAME,
  DB_VERSION: DB_VERSION,
  PV_FILE_STORE: PV_FILE_STORE
};

export { PvError, PvFile, PvFileIDB, PvFileMem, arrayBufferToBase64AtIndex, arrayBufferToStringAtIndex, base64ToUint8Array, buildWasm, dbConfig, fetchWithTimeout, fromBase64, fromPublicDirectory, getDB, isAccessKeyValid, loadModel, open, stringHeaderToObject, unsignedAddress };
